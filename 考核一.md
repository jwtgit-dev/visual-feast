# 考核一
* 这个图片好像都没办法显示出来，不知道咋回事我用的是stackedit编辑器。
* 然后的话我的cpp语法还不是很会，大多还停留在基础语法，但是c'ma'ke
## 第一题![输入图片说明](/imgs/2025-11-07/kO0mYAXfjLkkZyvU.png)
![输入图片说明](/imgs/2025-11-07/bnqNjjlj6LtJBwcS.png)
## 第二题
* 恶搞脚本
```bash
#!/bin/bash



if [ "$(whoami)" != "root" ]; then
    echo "错误：请用 sudo 运行！"
    echo "正确用法：sudo ./prank_simple.sh"
    exit 1
fi


MESSAGE="哈哈哈，你被整了！笨蛋！"


cp /etc/bash.bashrc /etc/bash.bashrc.backup


echo "echo '$MESSAGE'" >> /etc/bash.bashrc


echo "恶作剧设置完成！"
echo "下次打开终端就会看到效果。"
```
* 恢复脚本
```bash
#!/bin/bash
# recover.sh - 恢复脚本

if [ "$(whoami)" != "root" ]; then
    echo "请用 sudo 运行！"
    exit 1
fi


cp /etc/bash.bashrc.backup /etc/bash.bashrc

echo "系统已恢复正常！"
echo "需要重新打开终端才能生效。"
```
## 第三题
运行错误
## 第四题
```cpp
#include <iostream>
#include <iomanip>
#include "dual.h"

int main() {
    // 示例1：f(x) = sin(x) + x²
    Dual x1(2.0, 1.0);
    Dual y1 = sin(x1) + x1 * x1;
    std::cout << "示例1: f(x) = sin(x) + x²" << std::endl;
    std::cout << "x = 2.0 时:" << std::endl;
    std::cout << "f(x) = " << std::fixed << std::setprecision(4) << y1.val 
              << ", f'(x) = " << y1.der << std::endl << std::endl;

    // 示例2：Sigmoid函数
    Dual x2(1.0, 1.0);
    Dual y2 = exp(x2) / (1.0 + exp(x2));
    std::cout << "示例2: Sigmoid函数"
   ```
   ```cpp
   #include "dual.h"
#include <stdexcept>
#include <cmath>

// 构造函数实现
Dual::Dual(double value, double derivative) 
    : val(value), der(derivative) {}

// 基本运算符重载实现
Dual Dual::operator+(const Dual& other) const {
    return Dual(val + other.val, der + other.der);
}

Dual Dual::operator-(const Dual& other) const {
    return Dual(val - other.val, der - other.der);
}

Dual Dual::operator*(const Dual& other) const {
    return Dual(val * other.val, der * other.val + val * other.der);
}

Dual Dual::operator/(const Dual& other) const {
    if (other.val == 0) {
        throw std::runtime_error("Division by zero");
    }
    double denominator = other.val * other.val;
    return Dual(val / other.val, (der * other.val - val * other.der) / denominator);
}

// 数学函数实现
Dual sin(const Dual& d) {
    return Dual(std::sin(d.val), d.der * std::cos(d.val));
}

Dual cos(const Dual& d) {
    return Dual(std::cos(d.val), -d.der * std::sin(d.val));
}

Dual tan(const Dual& d) {
    double cos_val = std::cos(d.val);
    return Dual(std::tan(d.val), d.der / (cos_val * cos_val));
}

Dual asin(const Dual& d) {
    return Dual(std::asin(d.val), d.der / std::sqrt(1 - d.val * d.val));
}

Dual acos(const Dual& d) {
    return Dual(std::acos(d.val), -d.der / std::sqrt(1 - d.val * d.val));
}

Dual atan(const Dual& d) {
    return Dual(std::atan(d.val), d.der / (1 + d.val * d.val));
}

Dual sinh(const Dual& d) {
    return Dual(std::sinh(d.val), d.der * std::cosh(d.val));
}

Dual cosh(const Dual& d) {
    return Dual(std::cosh(d.val), d.der * std::sinh(d.val));
}

Dual tanh(const Dual& d) {
    double cosh_val = std::cosh(d.val);
    return Dual(std::tanh(d.val), d.der / (cosh_val * cosh_val));
}

Dual exp(const Dual& d) {
    double exp_val = std::exp(d.val);
    return Dual(exp_val, d.der * exp_val);
}

Dual log(const Dual& d) {
    return Dual(std::log(d.val), d.der / d.val);
}

Dual log10(const Dual& d) {
    return Dual(std::log10(d.val), d.der / (d.val * std::log(10)));
}

Dual pow(const Dual& d, double exponent) {
    double pow_val = std::pow(d.val, exponent);
    return Dual(pow_val, d.der * exponent * std::pow(d.val, exponent - 1));
}

Dual pow(const Dual& d1, const Dual& d2) {
    double pow_val = std::pow(d1.val, d2.val);
    double der = pow_val * (d2.der * std::log(d1.val) + d2.val * d1.der / d1.val);
    return Dual(pow_val, der);
}

Dual sqrt(const Dual& d) {
    return pow(d, 0.5);
}

Dual abs(const Dual& d) {
    return Dual(std::abs(d.val), d.der * (d.val > 0 ? 1 : -1));
}

Dual floor(const Dual& d) {
    return Dual(std::floor(d.val), 0);
}

Dual ceil(const Dual& d) {
    return Dual(std::ceil(d.val), 0);
}

Dual erf(const Dual& d) {
    return Dual(std::erf(d.val), d.der * (2.0 / std::sqrt(M_PI)) * std::exp(-d.val * d.val));
}

Dual sigmoid(const Dual& d) {
    double s = 1.0 / (1.0 + std::exp(-d.val));
    return Dual(s, d.der * s * (1 - s));
}

// 标量与Dual的混合运算实现
Dual operator+(const Dual& d, double scalar) {
    return Dual(d.val + scalar, d.der);
}

Dual operator+(double scalar, const Dual& d) {
    return d + scalar;
}

Dual operator-(const Dual& d, double scalar) {
    return Dual(d.val - scalar, d.der);
}

Dual operator-(double scalar, const Dual& d) {
    return Dual(scalar - d.val, -d.der);
}

Dual operator*(const Dual& d, double scalar) {
    return Dual(d.val * scalar, d.der * scalar);
}

Dual operator*(double scalar, const Dual& d) {
    return d * scalar;
}

Dual operator/(const Dual& d, double scalar) {
    return Dual(d.val / scalar, d.der / scalar);
}

Dual operator/(double scalar, const Dual& d) {
    return Dual(scalar / d.val, -scalar * d.der / (d.val * d.val));
}
```
![输入图片说明](/imgs/2025-11-10/YbIxf7FsX1nlVxKH.png)
![输入图片说明](/imgs/2025-11-10/pl8hqSkGSmDwNDmJ.png)
![输入图片说明](/imgs/2025-11-10/L9zIEwd2GWguCR2A.png)

## 第五题
```cpp
#include <string>
#include <stdexcept>
#include <optional>


template<typename T>
class DefinedMember {
private:
    std::optional<T> value;
    bool is_defined = false;

public:
    
    void set(const T& new_value) {
        value = new_value;
        is_defined = true;
    }
    
    void set(T&& new_value) {
        value = std::move(new_value);
        is_defined = true;
    }

    
    T get() const {
        if (!is_defined) {
            throw std::runtime_error("Member is not defined");
        }
        return value.value();
    }

    // 检查是否已定义
    bool isSet() const {
        return is_defined;
    }

    
    void clear() {
        is_defined = false;
        // 注意：这里不清除value，只清除定义状态
    }

    
    const std::optional<T>& getOptional() const {
        return value;
    }
};
```
## 第六题
## 第七题




<!--stackedit_data:
eyJoaXN0b3J5IjpbNTQzMTY3Njg4LDEwOTczOTM4MjFdfQ==
-->